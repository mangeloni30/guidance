// import inspect
// import re
// import uuid
// from .._utils import ContentCapture

async function geneach(
  list_name: string,
  stop: string | string[] | null = null,
  max_iterations: number = 100,
  min_iterations: number = 0,
  num_iterations: number | null = null,
  hidden: boolean = false,
  join: string = "",
  single_call: boolean = false,
  single_call_temperature: number = 0.0,
  single_call_max_tokens: number = 500,
  single_call_top_p: number = 1.0,
  _parser_context: any = null
): Promise<void> {
  const block_content = _parser_context["block_content"];
  const parser = _parser_context["parser"];
  const variable_stack = _parser_context["variable_stack"];
  const parser_node = _parser_context["parser_node"];

  // Type assertions
  const assert = (condition: any, message: string) => {
    if (!condition) {
      throw new Error(message);
    }
  };

  assert(block_content.length === 1, "block_content length must be 1");
  assert(
    !(hidden && single_call),
    "Cannot use hidden=True and single_call together"
  );
  assert(
    typeof list_name === "string",
    "Must provide a variable name to save the generated list to"
  );
  assert(
    !hidden || num_iterations !== null,
    "Cannot use hidden=True and variable length iteration together yet..."
  );
  const echo = !hidden;

  // num_iterations has priority over max_iterations if they are both set
  if (num_iterations !== null) {
    max_iterations = num_iterations;
    min_iterations = num_iterations;
  }

  if (max_iterations === null) {
    max_iterations = 1e10;
  }

  // give the list a default name
  if (list_name === null) {
    list_name = "generated_list";
  }

  // convert stop strings to tokens
  let max_stop_tokens: number | undefined;
  if (stop !== false) {
    if (stop === null) {
      max_stop_tokens = 2;
    } else {
      const stopArray = Array.isArray(stop) ? stop : [stop];
      max_stop_tokens = Math.max(
        ...stopArray.map((s) => parser.program.llm.encode(s).length)
      ) + 2;
    }
  }

  if (!single_call) {
    for (let i = 0; i < max_iterations; i++) {
      // capture the content generated by the block
      const new_content: any[] = [];
      variable_stack.push({
        "@index": i,
        "@first": i === 0,
        this: {},
      });

      // add the join string if we are not on the first iteration
      if (i > 0 && join !== "") {
        new_content.push(join);
      }

      // visit the block content
      new_content.push(
        await parser.visit(
          block_content[0],
          variable_stack,
          {
            next_node: _parser_context["next_node"],
            next_next_node: _parser_context["next_next_node"],
            prev_node: _parser_context["prev_node"],
          }
        )
      );

      // update the list variable (we do this each time we get a new item so that streaming works)
      const block_variables = variable_stack.pop()["this"];
      variable_stack[list_name] = variable_stack[list_name] || [];
      variable_stack[list_name].push(block_variables);

      // stop if we are not executing anymore
      if (!parser.executing) {
        // make any unfinished `this.` references point to the.
      }
}

geneach.is_block = true;

function _escape_group_name(name: string): string {
  return name.replace("@", "_AT_").replace(".", "_DOT_");
}

function _unescape_group_name(name: string): string {
  return name.replace("_AT_", "@").replace("_DOT_", ".");
}

